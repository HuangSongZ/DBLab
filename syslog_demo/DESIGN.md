# 1 Syslog 系统设计文档

## 1.1 系统概述

本演示系统模拟了一个日志系统实现，重点展示了多进程环境下的日志收集和处理机制。系统由两个主要组件组成：syslogger 进程和后端进程，它们通过命名管道进行通信。

## 1.2 架构设计

### 1.2.1 整体架构

```c
+-------------+     +-------------+     +-------------+
| 后端进程 1   |     | 后端进程 2   |     | 后端进程 N   |
+-------------+     +-------------+     +-------------+
       |                   |                   |
       v                   v                   v
       +-------------------+-------------------+
                           |
                           | 命名管道 (FIFO)
                           |
                           v
                    +-------------+
                    | syslogger   |
                    | 进程        |
                    +-------------+
                           |
                           v
                    +-------------+
                    | 日志文件     |
                    +-------------+
```

### 1.2.2 组件说明

1. **后端进程**：模拟数据库后端进程，生成各种级别的日志消息并发送到 syslogger 进程
2. **命名管道**：提供进程间通信机制，支持多个后端进程并发写入
3. **syslogger 进程**：负责从管道读取日志消息，重组分块消息，并写入日志文件
4. **日志文件**：存储所有收集到的日志消息

## 1.3 协议设计

### 1.3.1 日志消息协议

日志消息通过特殊的协议头进行传输，确保在高并发环境下的正确处理：

```c
typedef struct {
    char        nuls[2];        /* 始终为 \0\0，用于协议识别 */
    unsigned short len;         /* 数据块大小 */
    int         pid;            /* 发送进程的PID */
    char        is_last;        /* 是否为消息的最后一块 */
    char        data[0];        /* 柔性数组成员，存储实际数据 */
} PipeProtoHeader;
```

### 1.3.2 分块传输机制

大型日志消息被分割成多个块进行传输：

1. 每个块大小不超过 PIPE_MAX_PAYLOAD（通常基于 PIPE_BUF 定义）
2. 非最后一块的 is_last 标志设置为 'f'
3. 最后一块的 is_last 标志设置为 't'
4. 每个块都包含完整的协议头

## 1.4 关键算法

### 1.4.1 日志消息分块


输入: 日志消息 data，长度 len

输出: 通过管道发送的消息块

1. 初始化协议头，设置进程 ID
2. 当 len > PIPE_MAX_PAYLOAD 时:
   a. 设置 is_last = 'f'（非最后一块）
   b. 设置 len = PIPE_MAX_PAYLOAD
   c. 复制 PIPE_MAX_PAYLOAD 字节数据到协议数据区
   d. 写入管道
   e. 更新 data 指针和剩余长度
3. 设置 is_last = 't'（最后一块）
4. 设置 len 为剩余长度
5. 复制剩余数据到协议数据区
6. 写入管道


### 1.4.2 消息块重组

输入: 从管道读取的消息块

输出: 重组后的完整消息

1. 根据 PID 查找或创建待处理块
2. 将消息块数据追加到待处理块缓冲区
3. 检查 is_last 标志:
   a. 如果为 't'，表示接收到完整消息
   b. 处理完整消息（写入日志文件）
   c. 重置待处理块
4. 如果不是最后一块，等待更多数据


## 1.5 并发控制

### 1.5.1 原子写入保证

系统利用 POSIX 标准对 PIPE_BUF 大小内写入的原子性保证，确保在高并发环境下不同进程的日志消息不会在字节级别交错。

### 1.5.2 进程间同步

1. **写入阻塞**：当管道缓冲区已满时，后端进程的写入操作会阻塞
2. **非阻塞读取**：syslogger 使用非阻塞 I/O 和 select() 机制处理管道输入

## 1.6 性能考虑

### 1.6.1 缓冲区管理

1. 动态分配和扩展消息缓冲区，适应不同大小的日志消息
2. 重用缓冲区，避免频繁的内存分配和释放

### 1.6.2 I/O 优化

1. 使用行缓冲模式写入日志文件，平衡实时性和性能
2. 批量处理日志消息，减少系统调用次数


## 1.7 测试策略

### 1.7.1 功能测试

1. 单一后端进程日志写入测试
2. 多后端进程并发写入测试
3. 大型日志消息分块传输测试
4. 错误处理和恢复测试

### 1.7.2 性能测试

1. 高频率日志写入测试
2. 大量后端进程并发测试
3. 管道缓冲区满时的阻塞行为测试

## 1.8 参考资料

1. POSIX 管道规范
2. Linux 管道实现
3. PostgreSQL 日志系统设计
